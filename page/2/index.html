<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Page 2 | Steven的雕虫小技</title>
  <meta name="author" content="Steven">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Steven的雕虫小技"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Steven的雕虫小技" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Steven的雕虫小技</a></h1>
  <h2><a href="/">Golang/Java/C</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-09-02T13:50:00.000Z"><a href="/2013/09/02/switch-erlang-version/">Sep 2 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/09/02/switch-erlang-version/">Switch Erlang Version Shell</a></h1>
  

    </header>
    <div class="entry">
      
        <p>So, When I used brew to installed erlang, that’s version was too old. I compiled a new version to /usr/local/Cellar/erlang/RXXXX folder.</p>
<p>I wanna both versions to being, wrote a shell to switch them:)</p>
<p>./switch_erlang YOUR_ERLANG_FOLDER</p>
<p>My computer’s like this:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre>cd /usr/<span class="built_in">local</span>/Cellar/erlang/
./switch_erlang.sh R15B03-<span class="number">1</span>
Processing R15B03-<span class="number">1</span> -&gt; /usr/<span class="built_in">local</span>/bin
/usr/<span class="built_in">local</span>/Cellar/erlang/R15B03-<span class="number">1</span>/bin
Deleting <span class="built_in">files</span> ct_run dialyzer epmd erl erlc escript run_erl run_test to_erl typer
Linking <span class="built_in">files</span>:
<span class="built_in">ln</span> -s /usr/<span class="built_in">local</span>/Cellar/erlang/R15B03-<span class="number">1</span>/bin/ct_run ct_run
<span class="built_in">ln</span> -s /usr/<span class="built_in">local</span>/Cellar/erlang/R15B03-<span class="number">1</span>/bin/dialyzer dialyzer
<span class="built_in">ln</span> -s /usr/<span class="built_in">local</span>/Cellar/erlang/R15B03-<span class="number">1</span>/bin/epmd epmd
<span class="built_in">ln</span> -s /usr/<span class="built_in">local</span>/Cellar/erlang/R15B03-<span class="number">1</span>/bin/erl erl
<span class="built_in">ln</span> -s /usr/<span class="built_in">local</span>/Cellar/erlang/R15B03-<span class="number">1</span>/bin/erlc erlc
<span class="built_in">ln</span> -s /usr/<span class="built_in">local</span>/Cellar/erlang/R15B03-<span class="number">1</span>/bin/escript escript
<span class="built_in">ln</span> -s /usr/<span class="built_in">local</span>/Cellar/erlang/R15B03-<span class="number">1</span>/bin/run_erl run_erl
<span class="built_in">ln</span> -s /usr/<span class="built_in">local</span>/Cellar/erlang/R15B03-<span class="number">1</span>/bin/run_test run_test
<span class="built_in">ln</span> -s /usr/<span class="built_in">local</span>/Cellar/erlang/R15B03-<span class="number">1</span>/bin/to_erl to_erl
<span class="built_in">ln</span> -s /usr/<span class="built_in">local</span>/Cellar/erlang/R15B03-<span class="number">1</span>/bin/typer typer
Processed OK
</pre></td></tr></table></figure>

<script src="https://gist.github.com/6413056.js"></script>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-08-08T10:30:00.000Z"><a href="/2013/08/08/cyu-yan-zhi-zhen-he-nei-cun-bu-ju-de-na-xie-shi/">Aug 8 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/08/08/cyu-yan-zhi-zhen-he-nei-cun-bu-ju-de-na-xie-shi/">C语言指针和内存布局的那些事</a></h1>
  

    </header>
    <div class="entry">
      
        <p>C语言不如说是内存操作的语言，指针和内存就是C语言的精华一点也不为过。这是篇非常基础的文章，好记性不如烂笔头，以便自己查阅。</p>
<p>我们都知道指针的作用是指向另外一个内存的地址</p>
<p><code>void *addr = &amp;memory;</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;stdio.h&gt;</span>

<span class="keyword">int</span> main()
{
    <span class="keyword">int</span> i = <span class="number">42</span>;
    <span class="keyword">int</span> *pi = &amp;i;
    <span class="built_in">printf</span>(<span class="string">"i = %d, i's address = %p\n"</span>, i, &amp;i);
    <span class="built_in">printf</span>(<span class="string">"pi = %p, pi's address = %p, pi dereference = %d\n"</span>, pi, &amp;pi, *pi);
    <span class="keyword">return</span> <span class="number">0</span>;
}
</pre></td></tr></table></figure>


<p>其<br><code>char *str = &quot;hello world&quot;;</code></p>
<p>表示一个char指针指向内存堆(heap)的地址.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;stdio.h&gt;</span>

<span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)
{
    <span class="keyword">char</span> *str = <span class="string">"hello world"</span>;
    <span class="built_in">printf</span>(<span class="string">"str %s\n"</span>, str);
    <span class="built_in">printf</span>(<span class="string">"*str = %p \n"</span>, *str);
    <span class="built_in">printf</span>(<span class="string">"&amp;str = %p \n"</span>, &amp;str);
    <span class="built_in">printf</span>(<span class="string">"str pointer =  %p\n"</span>, str);
    <span class="keyword">return</span> <span class="number">0</span>;
}
</pre></td></tr></table></figure>


<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>$ ./helloworld
<span class="keyword">str</span> hello world
*<span class="keyword">str</span> = <span class="number">0x68</span>
&<span class="keyword">str</span> = <span class="number">0x7fff68be3528</span>
<span class="keyword">str</span> pointer =  <span class="number">0x108fe4f28</span>
</pre></td></tr></table></figure>

<p>char*表示指向char类型的地址，已经分配的字符串是无法修改的（通过char*定义的，实际上也能修改）。</p>
<p>好吧，下面这个例子很容易说明问题:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;stdio.h&gt;</span>

<span class="keyword">void</span> swapchar(<span class="keyword">char</span> **a, <span class="keyword">char</span> **b)
{
  <span class="built_in">printf</span>(<span class="string">"in function *a = %p, *b = %p\n"</span>, *a, *b);
  <span class="keyword">char</span> *temp = *a;
  *a = *b;
  *b = temp;
  <span class="built_in">printf</span>(<span class="string">"in function a's address %p, b's address %p\n"</span>, a, b);
}

<span class="keyword">void</span> swapint(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)
{
  <span class="keyword">int</span> temp = *a;
  *a = *b;
  *b = temp;
}

<span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)
{
  <span class="keyword">int</span> x = <span class="number">3</span>, y = <span class="number">5</span>;
  swapint(&amp;x, &amp;y);
  <span class="built_in">printf</span>(<span class="string">"x = %d y = %d\n\n"</span>, x, y);

  <span class="keyword">char</span> *a = <span class="string">"husband"</span>;
  <span class="keyword">char</span> *b = <span class="string">"wife"</span>;
  <span class="built_in">printf</span>(<span class="string">"a = %s, a's pointer = %p, &amp;a = %p\n"</span>, a, a, &amp;a);
  <span class="built_in">printf</span>(<span class="string">"b = %s, b's pointer = %p, &amp;b = %p\n"</span>, b, b, &amp;b);

  swapchar(&amp;a, &amp;b);
  <span class="built_in">printf</span>(<span class="string">"a = %s, a's pointer = %p, &amp;a = %p\n"</span>, a, a, &amp;a);
  <span class="built_in">printf</span>(<span class="string">"b = %s, b's pointer = %p, &amp;b = %p\n"</span>, b, b, &amp;b);

  <span class="keyword">return</span> <span class="number">0</span>;
}
</pre></td></tr></table></figure>


<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>$ ./swapstr
x = <span class="number">5</span> y = <span class="number">3</span>

a = husband, a<span class="attribute">'s</span> pointer = <span class="number">0x101673ebe</span>, &a = <span class="number">0x7fff61272520</span>
b = wife, b<span class="attribute">'s</span> pointer = <span class="number">0x101673ec6</span>, &b = <span class="number">0x7fff61272518</span>
<span class="keyword">in</span> <span class="keyword">function</span> *a = <span class="number">0x101673ebe</span>, *b = <span class="number">0x101673ec6</span>
<span class="keyword">in</span> <span class="keyword">function</span> a<span class="attribute">'s</span> address <span class="number">0x7fff61272520</span>, b<span class="attribute">'s</span> address <span class="number">0x7fff61272518</span>
a = wife, a<span class="attribute">'s</span> pointer = <span class="number">0x101673ec6</span>, &a = <span class="number">0x7fff61272520</span>
b = husband, b<span class="attribute">'s</span> pointer = <span class="number">0x101673ebe</span>, &b = <span class="number">0x7fff61272518</span>
</pre></td></tr></table></figure>

<p>swapint工作的好好的，假设要是照葫芦画瓢写个swapchar你可以试试，肯定是没法工作的，因为在char*本身不会保存数据（保存数据的是内存堆,并不是一个字节的char），所以在*char解引用的时候得到的是堆地址的第一个字符（首地址）。上面的例子比较清楚，另外补充说明：一级指针解引后得到的是数据，而二级指针解引后得到的是数据的地址，也就是说我们在解引以及char的时候得到的数据，无法取得地址，从而没法进行char地址交换。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>void badswapchar(char <span class="variable">*a</span>, char <span class="variable">*b</span>)
{
  char temp = <span class="variable">*a</span>;
  <span class="variable">*a</span> = <span class="variable">*b</span>;
  <span class="variable">*b</span> = temp;
}
</pre></td></tr></table></figure>

<p>上面这个是不能工作的，当然，我们还可以把函数参数换成void<em>就可以工作了，void</em>可以转换成任意地址，这个强大的真让人赞叹，什么都能转换，有时候得需要一定的想象力才能把程序写的漂亮：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">void</span> badswapchar(<span class="keyword">void</span> *a, <span class="keyword">void</span> *b)
{
  <span class="keyword">char</span> *x = *((<span class="keyword">char</span>**)a); <span class="comment">// 先转换成一个二级指针，从而能取到堆的地址</span>

  *(<span class="keyword">char</span>**)a = *(<span class="keyword">char</span>**)b;
  *(<span class="keyword">char</span>**)b = x;
}
</pre></td></tr></table></figure>

<p>下面的这个例子是关于swap通用函数的使用，在C++中通常大多数会采用模板的方式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;string.h&gt;</span>

<span class="keyword">void</span> swap(<span class="keyword">void</span> *ap, <span class="keyword">void</span> *bp, <span class="keyword">int</span> size)
{
  <span class="keyword">char</span> buffer[size];

  <span class="built_in">memcpy</span>(buffer, ap, size);
  <span class="built_in">memcpy</span>(ap, bp, size);
  <span class="built_in">memcpy</span>(bp, buffer, size);
}

<span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)
{
  <span class="keyword">int</span> x = <span class="number">44</span>;
  <span class="keyword">short</span>  y = <span class="number">5</span>;
  <span class="built_in">printf</span>(<span class="string">"original x's memory layout:\n"</span>);
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(<span class="keyword">int</span>); i++)
    <span class="built_in">printf</span>(<span class="string">"%d "</span>, *((<span class="keyword">char</span>*)((<span class="keyword">char</span>*)&amp;x + i)));
  <span class="built_in">printf</span>(<span class="string">"\n"</span>);

  <span class="built_in">printf</span>(<span class="string">"original y's memory layout:\n"</span>);
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(<span class="keyword">short</span>); i++)
    <span class="built_in">printf</span>(<span class="string">"%d "</span>, *((<span class="keyword">char</span>*)((<span class="keyword">char</span>*)&amp;y + i)));
  <span class="built_in">printf</span>(<span class="string">"\n"</span>);

  swap(&amp;x, &amp;y, <span class="number">2</span>);

  <span class="built_in">printf</span>(<span class="string">"exchanged x's memory layout:\n"</span>);
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(<span class="keyword">int</span>); i++)
    <span class="built_in">printf</span>(<span class="string">"%d "</span>, *((<span class="keyword">char</span>*)((<span class="keyword">char</span>*)&amp;x + i)));
  <span class="built_in">printf</span>(<span class="string">"\n"</span>);

  <span class="built_in">printf</span>(<span class="string">"exchanged y's memory layout:\n"</span>);
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(<span class="keyword">short</span>); i++)
    <span class="built_in">printf</span>(<span class="string">"%d "</span>, *((<span class="keyword">char</span>*)((<span class="keyword">char</span>*)&amp;y + i)));
  <span class="built_in">printf</span>(<span class="string">"\n"</span>);

  <span class="built_in">printf</span>(<span class="string">"x = %d, y = %d\n"</span>, x, y);
  <span class="keyword">return</span> <span class="number">0</span>;
}
</pre></td></tr></table></figure>


<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>$ ./swap
original x's memory <span class="keyword">layout</span>:
<span class="number">44</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>
original y's memory <span class="keyword">layout</span>:
<span class="number">5</span> <span class="number">0</span>
exchanged x's memory <span class="keyword">layout</span>:
<span class="number">5</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>
exchanged y's memory <span class="keyword">layout</span>:
<span class="number">44</span> <span class="number">0</span>
x = <span class="number">5</span>, y = <span class="number">44</span>
</pre></td></tr></table></figure>

<p>这个例子如果在Big Endian机器上跑的话，会出现问题，大多数机器都会是Little Endian，像PowerPC,Motorola的CPU会是Big序.<br>网络传输大多目前都采用Big Endian，Java的网络采用的是Big Endian。</p>
<p>那我们来看下内存布局，将一个int跟short进行交换，int本身是4个字节，short两个字节，两个变量的空间不同必然会导致数据出现问题，但由于是little endian序，反而没问题。</p>
<p>补充一个检验机器是什么字节序的代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;stdio.h&gt;</span>

<span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)
{
  <span class="keyword">char</span> endian[<span class="number">2</span>] = {<span class="number">0</span>, <span class="number">1</span>};
  <span class="keyword">short</span> test = *(<span class="keyword">short</span>*)endian;
  <span class="keyword">if</span> (test == <span class="number">1</span>)
    <span class="built_in">printf</span>(<span class="string">"big endian\n"</span>);
  <span class="keyword">else</span>
    <span class="built_in">printf</span>(<span class="string">"little endian\n"</span>);
  <span class="keyword">return</span> <span class="number">0</span>;
}
</pre></td></tr></table></figure>



<p>下面是一个通用的search数组，找到index的例子，从中你可以感受到内存的操作和比较，注释掉的部分可以打开来代替memcmp函数的功能。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;string.h&gt;</span>
<span class="keyword">int</span> isearch(<span class="keyword">void</span> *key, <span class="keyword">void</span> *base, <span class="keyword">int</span> n, <span class="keyword">int</span> element_size)
{
  <span class="keyword">int</span> index = -<span class="number">1</span>;
  <span class="keyword">int</span> j = <span class="number">0</span>;

  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {
    <span class="keyword">void</span> *val = (<span class="keyword">char</span>*)base + i * element_size;
    <span class="keyword">if</span> (<span class="built_in">memcmp</span>(val, key, element_size) == <span class="number">0</span>)
      <span class="keyword">return</span> i;
    <span class="comment">/*
    for (j = 0; j &lt; element_size; j++) {
      if ( *((char*)((char*)key + j)) != *((char*)((char*)val + j)) )
        break;
    }
    if (j == element_size) {
      index = i;
      break;
    }
    */</span>
  }
  <span class="keyword">return</span> index;
}

<span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)
{
  <span class="keyword">int</span> arr[<span class="number">9</span>] = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>};
  <span class="keyword">int</span> k = <span class="number">4</span>;
  <span class="keyword">int</span> index = isearch(&amp;k, arr, <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]), <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]));
  <span class="built_in">printf</span>(<span class="string">"array is "</span>);
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]); i++)
    <span class="built_in">printf</span>(<span class="string">"%d "</span>, arr[i]);
  <span class="built_in">printf</span>(<span class="string">"\n"</span>);
  <span class="built_in">printf</span>(<span class="string">"find %d, index = %d\n"</span>, k, index);
  <span class="keyword">return</span> <span class="number">0</span>;
}
</pre></td></tr></table></figure>


<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>$./isearch
<span class="keyword">array</span> <span class="keyword">is</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>
find <span class="number">4</span>, <span class="keyword">index</span> = <span class="number">3</span>
</pre></td></tr></table></figure>

<p>好的，我们继续再来看看struct的内存布局的一个例子:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;stdio.h&gt;</span>

<span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)
{
  <span class="keyword">struct</span> fracnum {
    <span class="keyword">int</span> num;
    <span class="keyword">int</span> denum;
  };

  <span class="keyword">struct</span> fracnum pi;
  pi.num = <span class="number">22</span>;
  pi.denum = <span class="number">7</span>;

  <span class="built_in">printf</span>(<span class="string">"fracnum's size = %ld\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> fracnum));
  <span class="built_in">printf</span>(<span class="string">"&amp;pi = %p\n"</span>, &amp;pi);
  <span class="built_in">printf</span>(<span class="string">"&amp;(pi.denum) = %p\n"</span>, &amp;(pi.denum));
  <span class="built_in">printf</span>(<span class="string">"&amp;(pi.num) = %p\n"</span>, &amp;(pi.num));
  <span class="built_in">printf</span>(<span class="string">"((struct fracnum*)&amp;(pi.denum))-&gt;num = %d\n"</span>,
         ((<span class="keyword">struct</span> fracnum*)&amp;(pi.denum))-&gt;num);
  <span class="built_in">printf</span>(<span class="string">"((struct fracnum*)&amp;(pi.denum))-&gt;denum = %d\n"</span>,
         ((<span class="keyword">struct</span> fracnum*)&amp;(pi.denum))-&gt;denum);
  <span class="built_in">printf</span>(<span class="string">"&amp;(((struct fracnum*)&amp;(pi.denum))-&gt;denum) = %p\n"</span>,
         &amp;(((<span class="keyword">struct</span> fracnum*)&amp;(pi.denum))-&gt;denum));

  ((<span class="keyword">struct</span> fracnum*)&amp;(pi.denum))-&gt;num = <span class="number">12</span>; <span class="comment">// notice the address.</span>
  ((<span class="keyword">struct</span> fracnum*)&amp;(pi.denum))-&gt;denum = <span class="number">33</span>; <span class="comment">// over the boundary.</span>
  <span class="built_in">printf</span>(<span class="string">"num = %d denum = %d\n"</span>, pi.num, pi.denum); <span class="comment">// 22, 12</span>
  <span class="built_in">printf</span>(<span class="string">"unknown data = %d\n"</span>, *((<span class="keyword">int</span>*)((<span class="keyword">char</span>*)&amp;pi + <span class="number">8</span>))); <span class="comment">// 33</span>
  <span class="keyword">return</span> <span class="number">0</span>;
}
</pre></td></tr></table></figure>


<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>$ ./fracnum
fracnum's size = <span class="number">8</span>
&<span class="constant">pi</span> = <span class="number">0x7fff69aea528</span>
&(<span class="constant">pi</span>.denum) = <span class="number">0x7fff69aea52c</span>
&(<span class="constant">pi</span>.num) = <span class="number">0x7fff69aea528</span>
((struct fracnum*)&(<span class="constant">pi</span>.denum))-&gt;num = <span class="number">7</span>
((struct fracnum*)&(<span class="constant">pi</span>.denum))-&gt;denum = <span class="number">1773053288</span>
&(((struct fracnum*)&(<span class="constant">pi</span>.denum))-&gt;denum) = <span class="number">0x7fff69aea530</span>
num = <span class="number">22</span> denum = <span class="number">12</span>
unknown data = <span class="number">33</span>
</pre></td></tr></table></figure>

<p>从上述的结果中我们可以看到,struct的第一个字段即是struct的地址，然后指针是依次叠加。</p>
<p>但内存应该这么来读，最底下的也就是struct/num的指针，然后上面的是denum的指针：</p>
<p><code>denum</code> &nbsp;0x7fff6372152c</p>
<p><code>num</code>  &nbsp;&nbsp;&nbsp;  0x7fff63721528</p>
<p>这样访问，取struct fracnum<em>的时候，每次都是以8个字节（fracnum的长度来取的），所以在用denum取得时候，将<em>*向上</em></em>访问到内存，越出边界了，下面我用unknown来代替未知的数据。</p>
<p><code>unknown</code> &nbsp; 0x7fff63721530 -&gt; 33</p>
<p><code>denum</code> &nbsp;0x7fff6372152c -&gt; 12</p>
<p><code>num</code>  &nbsp;&nbsp;&nbsp;  0x7fff63721528 -&gt; 22</p>
<p>好吧，我们再说一下内存字节对齐的问题（引自coolshell.cn）：</p>
<ol>
<li>struct X { int a; char b; int c; };</li>
<li>printf(“%d,”, sizeof(struct X));</li>
<li>struct Y { int a; char b; int c; char d};</li>
<li>printf(“%d\n”, sizeof(struct Y));</li>
</ol>
<p>这个代码会输出什么?</p>
<ul>
<li>a) 9，10</li>
<li>b)12, 12</li>
<li>c)12, 16</li>
</ul>
<p>答案是C，我想，你一定知道字节对齐，是向4的倍数对齐。</p>
<ul>
<li>但是，你知道为什么要字节对齐吗？还是因为性能。因为这些东西都在内存里，如果不对齐的话，我们的编译器就要向内存一个字节一个字节的取，这样一来，struct X，就需要取9次，太浪费性能了，而如果我一次取4个字节，那么我三次就搞定了。所以，这是为了性能的原因。</li>
<li>但是，为什么struct Y不向12 对齐，却要向16对齐，因为char d; 被加在了最后，当编译器计算一个结构体的尺寸时，是边计算，边对齐的。也就是说，编译器先看到了int，很好，4字节，然后是 char，一个字节，而后面的int又不能填上还剩的3个字节，不爽，把char b对齐成4，于是计算到d时，就是13 个字节，于是就是16啦。但是如果换一下d和c的声明位置，就是12了。</li>
</ul>
<p>另外，再提一下，上述程序的printf中的%d并不好，因为，在64位下，sizeof的size_t是unsigned long，而32位下是 unsigned int，所以，C99引入了一个专门给size_t用的%zu。这点需要注意。在64位平台下，C/C++ 的编译需要注意很多事。</p>
<p>再来看一个数组struct的例子:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;string.h&gt;</span>

<span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)
{
  <span class="keyword">struct</span> student {
    <span class="keyword">char</span> *name;
    <span class="keyword">char</span> suid[<span class="number">8</span>];
    <span class="keyword">int</span> numUnits;
  };

  <span class="keyword">struct</span> student peoplies[<span class="number">4</span>];
  peoplies[<span class="number">0</span>].numUnits = <span class="number">21</span>;
  peoplies[<span class="number">2</span>].name = strdup(<span class="string">"Adam"</span>);
  peoplies[<span class="number">3</span>].name = peoplies[<span class="number">0</span>].suid + <span class="number">6</span>;
  <span class="built_in">strcpy</span>(peoplies[<span class="number">1</span>].suid, <span class="string">"40415xx"</span>);
  <span class="built_in">strcpy</span>(peoplies[<span class="number">3</span>].name, <span class="string">"123456"</span>);
  peoplies[<span class="number">7</span>].suid[<span class="number">11</span>] = <span class="string">'A'</span>;
  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, peoplies[<span class="number">0</span>].numUnits);
  <span class="comment">// out put 909456435, actually is 6543(little endian order)</span>
  <span class="comment">// the memory of stucture's mapping order is</span>
  <span class="comment">// declaration's order is oppsite in real memory.</span>
  <span class="comment">/**
     |  numUnits  |   numUnits  |  numUnits |  numUnits |
     |    suid    |     suid    |    suid   |    suid   |
     |    name    |     name    |    name   |    name   |
   */</span>

  <span class="keyword">return</span> <span class="number">0</span>;
}
</pre></td></tr></table></figure>



<p>继续，我们再来讨论下内存中栈和堆的存储方式。<br>每种编译器实现内存管理的方式都不同,malloc/realloc/free的方式都不同，这里不讨论具体某种编译器的实现了，实在太复杂，简单说说吧：<br>堆的实现，就像是一条链上的进行分配。</p>
<p>为什么redis在计算内存的时候自己做了计数器呢？因为加上不同平台的指针大小。实际上free函数在调用的时候也只是关心你malloc/realloc内存的时候自己的指针，如果你malloc(100)想释放其中一段内存的大小，这样是不对的，因为本身内存管理算法也不允许这样做，只是关心的是在malloc/realloc后自身的指针。还有内存碎片的产生，以及一些启发式内存管理算法，到底是先找到最匹配的空间分配还是直接在链上先分配，以及如何进行内存压缩等等，都是堆内存管理器干的事情。</p>
<p>再来简单说说栈管理，先看计算机的数据处理方式，数据能被处理，计算机需要将内存的数据载入计算器，然后再通过ALU(算数逻辑处理单元)进行处理，在写入到相应的寄存器，然后在写回内存。当然他们这之间是通过硅晶线进行连接（不好意思，具体电路方面不熟悉，暂且这么说吧）。</p>
<p>栈数据分为代码段和数据段，代码段的指令存储是每条指令都是32位，4个字节，这个跟机器多少位没关系。关于指令的移动，当然有专有的寄存器来存储当前运行到哪条指令，举个for循环的例子，汇编代码中，跳转jmp还有组合使用一些判定指令，然后进行指令的跳转，也就是形成了for循环的结构，汇编指令的编写有时候是需要写完后面的指令，才能在写跳出循环（jmp到最后边的指令，因为你不知道后面指令的地址所以没法跳出去）的指令。</p>
<p>为什么是32位的指令，汇编语言包含了59种命令，如何表示这59种命令，或者说机器如何来识别这些命令，翻译成机器码就是每条指令的前面6位。<br>然后5位用来表示要赋值的寄存器的，再用5位表示获取寄存器的位置，剩下的10位有可能表示一个有符号的常数。<br>这些都是有可能出现的分配位置的方式，并不是绝对的，也可能只用前面5位表示要赋值的寄存器，后面的全是常数等等，这取决于你的具体指令。</p>
<p>Stack的调用，每个函数都有自己的栈空间，只能访问当前栈空间的数据，也就是每个函数的局部变量，参数变量等等，函数的开始先进行压栈操作，结束后在调回栈顶，逐级返回，为什么在C语言中的递归会出现栈溢出？因为没有优化，C语言编译器(GCC等等)并不会做尾递归优化，像lisp这样的函数语言大多数都可以进行为递归优化，不消耗栈空间。</p>
<p>另外，二级指针的使用，介绍一片文章（来自coolshell.cn）<br><a href="http://coolshell.cn/articles/8990.html" target="_blank">Linus：利用二级指针删除单向链表</a></p>
<p>先写到这里，有时间再继续整理相关内存的一些文章~</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-07-31T09:59:00.000Z"><a href="/2013/07/31/zshzhong-wen-luan-ma-wen-ti/">Jul 31 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/07/31/zshzhong-wen-luan-ma-wen-ti/">zsh中文乱码问题</a></h1>
  

    </header>
    <div class="entry">
      
        <p>zsh中文乱码问题</p>
<p>add below lines to your .zshrc file.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="keyword">export</span> LC_ALL=en_US.UTF-<span class="number">8</span>
<span class="keyword">export</span> LANG=en_US.UTF-<span class="number">8</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="built_in">source</span> .zshrc
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>restart zsh.
</pre></td></tr></table></figure>


      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-06-28T08:28:00.000Z"><a href="/2013/06/28/fabricshi-yong-xiao-ji/">Jun 28 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/06/28/fabricshi-yong-xiao-ji/">fabric使用小记</a></h1>
  

    </header>
    <div class="entry">
      
        <p>Fabric:</p>
<p><a href="https://github.com/fabric/fabric" target="_blank">https://github.com/fabric/fabric</a></p>
<p>Docs:</p>
<p><a href="http://fabfile.org" target="_blank">http://fabfile.org</a></p>
<p>Fabric主要应用与命令行指令打包程序和上传，进行一些部署任务。当然你做什么都可以。但基于SSH的是比较方便的。</p>
<p>fabric常用的几个命令行参数:</p>
<ol>
<li>-u USER 修改的是env.user</li>
<li>-p PASSWORD 修改的是env.password</li>
<li>-H HOSTS 修改的是env.hosts</li>
<li>-f FABFILE 指定要执行的fabfile，默认运行当前目录的fabfile.py</li>
</ol>
<p>指定某个任务的执行参数:</p>
<ol>
<li>使用:来分割任务和参数</li>
<li>使用,来分割参数</li>
<li>使用=来表示关键字参数.</li>
</ol>
<p>例子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="function"><span class="keyword">def</span> <span class="title">new_user</span><span class="params">(username, admin=<span class="string">'no'</span>, comment=<span class="string">"No comment provided"</span>)</span>:</span>
    print(<span class="string">"New User (%s): %s"</span> % (username, comment))
    <span class="keyword">pass</span>
</pre></td></tr></table></figure>

<ol>
<li><p>你可以指定username</p>
 <figure class="highlight $"><figcaption><span>fab new_user:steven```</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="attribute">2. 或者用关键字赋值

	```$ fab new_user:username</span>=<span class="string">steven</span>
</pre></td></tr></table></figure>
</li>
<li><p>如果两个参数都给了，那就按照位置赋值</p>
 <figure class="highlight $"><figcaption><span>fab new_user:steven,yes```</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="attribute">
4. 或者混合着使用

	```$ fab new_user:steven,admin</span>=<span class="string">yes</span>
</pre></td></tr></table></figure>


</li>
</ol>
<h4 id="注意：如果第一个参数采用关键字赋值的情况，那么后面的单词也必须是这种方式。">注意：如果第一个参数采用关键字赋值的情况，那么后面的单词也必须是这种方式。</h4>
<p><del>fab new_user:username=myusername,yes</del></p>
<p>几个常用的指令：</p>
<ol>
<li>lcd    本地的cd命令</li>
<li>local  本地的指令</li>
<li>cd     远端的cd命令</li>
<li>run    远端的指令</li>
</ol>
<p>一个打包和上传的例子：</p>
<script src="https://gist.github.com/c15a3dd722d2dc9c7df3.js"></script>


<p>现在本地执行了一系列的打包指令，然后cd到远端，再执行put指令，将本地的test-1.0.jar推送到远端.</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
    <a href="/" class="alignleft prev">Prev</a>
  
  
    <a href="/page/3/" class="alignright next">Next</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:www.100hack.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">Categories</h3>
  <ul class="entry">
  
    <li><a href="/categories/C语言/">C语言</a><small>1</small></li>
  
    <li><a href="/categories/Erlang/">Erlang</a><small>1</small></li>
  
    <li><a href="/categories/Golang/">Golang</a><small>1</small></li>
  
    <li><a href="/categories/Java/">Java</a><small>1</small></li>
  
    <li><a href="/categories/Lua/">Lua</a><small>1</small></li>
  
    <li><a href="/categories/Python/">Python</a><small>1</small></li>
  
    <li><a href="/categories/Terminal/">Terminal</a><small>1</small></li>
  
    <li><a href="/categories/生活/">生活</a><small>1</small></li>
  
    <li><a href="/categories/编辑器/">编辑器</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">Tags</h3>
  <ul class="entry">
  
    <li><a href="/tags/Blog/">Blog</a><small>1</small></li>
  
    <li><a href="/tags/DES/">DES</a><small>1</small></li>
  
    <li><a href="/tags/ECB/">ECB</a><small>1</small></li>
  
    <li><a href="/tags/Erlang/">Erlang</a><small>1</small></li>
  
    <li><a href="/tags/Fabric/">Fabric</a><small>1</small></li>
  
    <li><a href="/tags/Golang/">Golang</a><small>1</small></li>
  
    <li><a href="/tags/Netty/">Netty</a><small>1</small></li>
  
    <li><a href="/tags/Sublime/">Sublime</a><small>1</small></li>
  
    <li><a href="/tags/WebGame/">WebGame</a><small>1</small></li>
  
    <li><a href="/tags/zsh/">zsh</a><small>1</small></li>
  
    <li><a href="/tags/免密码ssh, ssh/">免密码ssh, ssh</a><small>1</small></li>
  
    <li><a href="/tags/指针/">指针</a><small>1</small></li>
  
    <li><a href="/tags/统计/">统计</a><small>1</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2014 Steven
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<script type="text/javascript">
var disqus_shortname = 'steven_cui';

(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>



<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>