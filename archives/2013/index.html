<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Archives: 2013 | Steven的雕虫小技</title>
  <meta name="author" content="Steven">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Steven的雕虫小技"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Steven的雕虫小技" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Steven的雕虫小技</a></h1>
  <h2><a href="/">Golang/Java/C</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
<h2 class="archive-title">2013</h2>


  
    <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-09-27T17:14:00.000Z"><a href="/2013/09/28/golang-skim/">Sep 28 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/09/28/golang-skim/">初见Golang</a></h1>
  

    </header>
    <div class="entry">
      
        <p>在最近用了大概不到一周的业余时间，Golang我已经深深的喜欢上了，并实现了并发的网游后端框架。</p>
<p>没有了Erlang一开始的那种朦胧感，看到Golang的时候，真的是给我眼前一亮的感觉，几乎综合了喜欢各种语言优势与一身的语言。</p>
<p>其实Golang比较早听说，在1.0版本以前大多数人都反映不稳定啊等等，那时候没有太刻意想去了解她，可现在地球人已经不能阻止Golang的流行了。</p>
<p>几个超级喜欢的特性，真是让我爱不释手了：  </p>
<ol>
<li>routine,channel（类似Erlang的mail box，这就是并发的基础啊）  </li>
<li>多参数返回（哎呀，Lua最爱的特性啊）  </li>
<li>duck typing（哈哈，来自Python，虽然我不怎么待见Python）  </li>
<li>闪电般的编译速度啊，地球人都看傻了。  </li>
<li>极其方便的结合C啊，尼玛啊，碉堡了。  </li>
<li>Slice，这个设计从一定程度上简化了数组操作和内存访问。</li>
</ol>
<p>目前唯一让我感觉遗憾的是，为什么没有宏定义。<br>通过gcc的预处理器可以简单的进行文件替换达到效果，但是还是很希望语言层能这么做，但可能会影响编译速度，我个人觉得实现不难，应该让程序员可以自由选择。</p>
<p>我曾做过Erlang的echo server跟go lang的echo server性能对比，几乎是一样的（Golang稍微慢10%），当然在没有任何逻辑的情况下。但是如果做数据广播和计算的话，Erlang就比较麻烦。。。</p>
<p>还有性能，Golang真的很快，在看到Golang系统库的时候，除了能学习系统库的设计模式，还能看到很多C底层的东西，这是一个面向给程序员和对性能带有偏执狂的宝库啊，真是太棒了，这对于对底层敢兴趣的人绝对是不容错过的，而且你在学习他的同时，你对C语言能力的提升将是潜默移化的。相比，Erlang更感觉是函数式和数据流的抽象，更多的关注业务层，如果想更深入，得需要极强的功底去把底层搞懂，而且很多优化必须要hack代码才能做到。</p>
<p>我可以大胆预测，未来将是Go的天下，关键是这个语言从底层到业务层什么都能做啊，爽爆了，以前用java的时候，想弄点底层搞死你，看到这里像我这样苦逼的同学有木有？</p>
<p>近两天我觉得Go的Log库并不好，虽然简单，但不能满足自己实现Log日志的功能。我想自己简单实现一个Log，功能包含两个，一个打印到控制台，另外一个输出到文件，支持日志的级别输出(Debug, Log, Error, Fatal)，然后就动手写了一个，并用了匿名函数做了封装（使用了闭包），区区200行，就实现了，这也只是看完Go语言没几个小时就做出来的。<br>有兴趣的同学可以去<a href="http://github.com/cuixin/log4g" target="_blank"><strong>浏览</strong></a></p>
<p>其实Go的Redis Client库没觉得有太简洁的，有时间自己实现个。</p>
<p>另外，我个人非常欣赏agentzh大神的lua-resty-redis库，洋洋洒洒300行就搞定，简洁唯美，代码越多越难维护，而且lua的这个module访问拦截，真是太强大了，我对lua一直处于赞赏状态，还有对table的操作简直太方便了，几乎任何一切数据结构能都能搞定。</p>
<p>八卦一下，Rob Pike怎么这么像Golang的吉祥物。。。<br>这位大神，并行不是并发的讲解即轻松又印象深刻，<a href="http://blog.golang.org/concurrency-is-not-parallelism" target="_blank"><strong>猛击这里</strong></a><br>还有这个Go语言的并发范式，<a href="http://www.youtube.com/watch?v=f6kdp27TYZs" target="_blank"><strong>猛击这里</strong></a><br>而且<a href="http://blog.golang.org/" target="_blank"><strong>blog.golang.org</strong></a>真是太多实用的东西了，都是大神啊，越简单的东西，越稳定，越能制造出非凡，Golang我觉得是在做性能和工作效率的权衡，个人感觉已经非常极致了。</p>
<p>总之，我无法阻挡继续深入Golang了，下来基本上所有的工作都需要围绕Go展开了，信心满满，Let’s Go！</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="请将此处替换成文章在你的站点中的ID" data-title="请替换成文章的标题" data-url="请替换成文章的网址"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"stevencui"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
<!-- 多说公共JS代码 end -->

  
    <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-09-25T03:28:00.000Z"><a href="/2013/09/25/sublimebao-cun-shi-zi-dong-zhuan-huan-tabcheng-kong-ge/">Sep 25 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/09/25/sublimebao-cun-shi-zi-dong-zhuan-huan-tabcheng-kong-ge/">Sublime保存时自动转换tab成空格</a></h1>
  

    </header>
    <div class="entry">
      
        <p>每次保存前手动转换实在太烦人，下面这个脚本可以帮到你。</p>
<ol>
<li>打开sublime的Preference -&gt; Browser Packages …  </li>
<li>新建一个目录ExpandTabsOnSave  </li>
<li>新建文件ExpandTabsOnSave.py  </li>
<li><p>把下面内容复制进去，保存  </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="keyword">import</span> sublime, sublime_plugin, os

<span class="class"><span class="keyword">class</span> <span class="title">ExpandTabsOnSave</span><span class="params">(sublime_plugin.EventListener)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">on_pre_save</span><span class="params">(self, view)</span>:</span>
        <span class="keyword">if</span> view.settings().get(<span class="string">'expand_tabs_on_save'</span>) == <span class="number">1</span>:
            view.window().run_command(<span class="string">'expand_tabs'</span>)
</pre></td></tr></table></figure>
</li>
<li><p>如果你想只是应用于当前项目，在 .sublime-project文件下添加：  </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="string">"settings"</span>: {
    <span class="string">"expand_tabs_on_save"</span>: <span class="literal">true</span>
}
</pre></td></tr></table></figure>

</li>
</ol>
<p>6.全局改变，打开Preferences -&gt; Settings - User添加：  </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="string">"settings"</span>: {
    <span class="string">"expand_tabs_on_save"</span>: <span class="literal">true</span>
}
</pre></td></tr></table></figure>

<p>原文地址：<a href="https://coderwall.com/p/zvyg7a" target="_blank">https://coderwall.com/p/zvyg7a</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="请将此处替换成文章在你的站点中的ID" data-title="请替换成文章的标题" data-url="请替换成文章的网址"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"stevencui"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
<!-- 多说公共JS代码 end -->

  
    <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-09-02T13:50:00.000Z"><a href="/2013/09/02/switch-erlang-version/">Sep 2 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/09/02/switch-erlang-version/">Switch Erlang Version Shell</a></h1>
  

    </header>
    <div class="entry">
      
        <p>So, When I used brew to installed erlang, that’s version was too old. I compiled a new version to /usr/local/Cellar/erlang/RXXXX folder.</p>
<p>I wanna both versions to being, wrote a shell to switch them:)</p>
<p>./switch_erlang YOUR_ERLANG_FOLDER</p>
<p>My computer’s like this:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre>cd /usr/<span class="built_in">local</span>/Cellar/erlang/
./switch_erlang.sh R15B03-<span class="number">1</span>
Processing R15B03-<span class="number">1</span> -&gt; /usr/<span class="built_in">local</span>/bin
/usr/<span class="built_in">local</span>/Cellar/erlang/R15B03-<span class="number">1</span>/bin
Deleting <span class="built_in">files</span> ct_run dialyzer epmd erl erlc escript run_erl run_test to_erl typer
Linking <span class="built_in">files</span>:
<span class="built_in">ln</span> -s /usr/<span class="built_in">local</span>/Cellar/erlang/R15B03-<span class="number">1</span>/bin/ct_run ct_run
<span class="built_in">ln</span> -s /usr/<span class="built_in">local</span>/Cellar/erlang/R15B03-<span class="number">1</span>/bin/dialyzer dialyzer
<span class="built_in">ln</span> -s /usr/<span class="built_in">local</span>/Cellar/erlang/R15B03-<span class="number">1</span>/bin/epmd epmd
<span class="built_in">ln</span> -s /usr/<span class="built_in">local</span>/Cellar/erlang/R15B03-<span class="number">1</span>/bin/erl erl
<span class="built_in">ln</span> -s /usr/<span class="built_in">local</span>/Cellar/erlang/R15B03-<span class="number">1</span>/bin/erlc erlc
<span class="built_in">ln</span> -s /usr/<span class="built_in">local</span>/Cellar/erlang/R15B03-<span class="number">1</span>/bin/escript escript
<span class="built_in">ln</span> -s /usr/<span class="built_in">local</span>/Cellar/erlang/R15B03-<span class="number">1</span>/bin/run_erl run_erl
<span class="built_in">ln</span> -s /usr/<span class="built_in">local</span>/Cellar/erlang/R15B03-<span class="number">1</span>/bin/run_test run_test
<span class="built_in">ln</span> -s /usr/<span class="built_in">local</span>/Cellar/erlang/R15B03-<span class="number">1</span>/bin/to_erl to_erl
<span class="built_in">ln</span> -s /usr/<span class="built_in">local</span>/Cellar/erlang/R15B03-<span class="number">1</span>/bin/typer typer
Processed OK
</pre></td></tr></table></figure>

<script src="https://gist.github.com/6413056.js"></script>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="请将此处替换成文章在你的站点中的ID" data-title="请替换成文章的标题" data-url="请替换成文章的网址"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"stevencui"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
<!-- 多说公共JS代码 end -->

  
    <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-08-08T10:30:00.000Z"><a href="/2013/08/08/cyu-yan-zhi-zhen-he-nei-cun-bu-ju-de-na-xie-shi/">Aug 8 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/08/08/cyu-yan-zhi-zhen-he-nei-cun-bu-ju-de-na-xie-shi/">C语言指针和内存布局的那些事</a></h1>
  

    </header>
    <div class="entry">
      
        <p>C语言不如说是内存操作的语言，指针和内存就是C语言的精华一点也不为过。这是篇非常基础的文章，好记性不如烂笔头，以便自己查阅。</p>
<p>我们都知道指针的作用是指向另外一个内存的地址</p>
<p><code>void *addr = &amp;memory;</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;stdio.h&gt;</span>

<span class="keyword">int</span> main()
{
    <span class="keyword">int</span> i = <span class="number">42</span>;
    <span class="keyword">int</span> *pi = &amp;i;
    <span class="built_in">printf</span>(<span class="string">"i = %d, i's address = %p\n"</span>, i, &amp;i);
    <span class="built_in">printf</span>(<span class="string">"pi = %p, pi's address = %p, pi dereference = %d\n"</span>, pi, &amp;pi, *pi);
    <span class="keyword">return</span> <span class="number">0</span>;
}
</pre></td></tr></table></figure>


<p>其<br><code>char *str = &quot;hello world&quot;;</code></p>
<p>表示一个char指针指向内存堆(heap)的地址.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;stdio.h&gt;</span>

<span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)
{
    <span class="keyword">char</span> *str = <span class="string">"hello world"</span>;
    <span class="built_in">printf</span>(<span class="string">"str %s\n"</span>, str);
    <span class="built_in">printf</span>(<span class="string">"*str = %p \n"</span>, *str);
    <span class="built_in">printf</span>(<span class="string">"&amp;str = %p \n"</span>, &amp;str);
    <span class="built_in">printf</span>(<span class="string">"str pointer =  %p\n"</span>, str);
    <span class="keyword">return</span> <span class="number">0</span>;
}
</pre></td></tr></table></figure>


<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>$ ./helloworld
<span class="keyword">str</span> hello world
*<span class="keyword">str</span> = <span class="number">0x68</span>
&<span class="keyword">str</span> = <span class="number">0x7fff68be3528</span>
<span class="keyword">str</span> pointer =  <span class="number">0x108fe4f28</span>
</pre></td></tr></table></figure>

<p>char*表示指向char类型的地址，已经分配的字符串是无法修改的（通过char*定义的，实际上也能修改）。</p>
<p>好吧，下面这个例子很容易说明问题:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;stdio.h&gt;</span>

<span class="keyword">void</span> swapchar(<span class="keyword">char</span> **a, <span class="keyword">char</span> **b)
{
  <span class="built_in">printf</span>(<span class="string">"in function *a = %p, *b = %p\n"</span>, *a, *b);
  <span class="keyword">char</span> *temp = *a;
  *a = *b;
  *b = temp;
  <span class="built_in">printf</span>(<span class="string">"in function a's address %p, b's address %p\n"</span>, a, b);
}

<span class="keyword">void</span> swapint(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)
{
  <span class="keyword">int</span> temp = *a;
  *a = *b;
  *b = temp;
}

<span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)
{
  <span class="keyword">int</span> x = <span class="number">3</span>, y = <span class="number">5</span>;
  swapint(&amp;x, &amp;y);
  <span class="built_in">printf</span>(<span class="string">"x = %d y = %d\n\n"</span>, x, y);

  <span class="keyword">char</span> *a = <span class="string">"husband"</span>;
  <span class="keyword">char</span> *b = <span class="string">"wife"</span>;
  <span class="built_in">printf</span>(<span class="string">"a = %s, a's pointer = %p, &amp;a = %p\n"</span>, a, a, &amp;a);
  <span class="built_in">printf</span>(<span class="string">"b = %s, b's pointer = %p, &amp;b = %p\n"</span>, b, b, &amp;b);

  swapchar(&amp;a, &amp;b);
  <span class="built_in">printf</span>(<span class="string">"a = %s, a's pointer = %p, &amp;a = %p\n"</span>, a, a, &amp;a);
  <span class="built_in">printf</span>(<span class="string">"b = %s, b's pointer = %p, &amp;b = %p\n"</span>, b, b, &amp;b);

  <span class="keyword">return</span> <span class="number">0</span>;
}
</pre></td></tr></table></figure>


<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>$ ./swapstr
x = <span class="number">5</span> y = <span class="number">3</span>

a = husband, a<span class="attribute">'s</span> pointer = <span class="number">0x101673ebe</span>, &a = <span class="number">0x7fff61272520</span>
b = wife, b<span class="attribute">'s</span> pointer = <span class="number">0x101673ec6</span>, &b = <span class="number">0x7fff61272518</span>
<span class="keyword">in</span> <span class="keyword">function</span> *a = <span class="number">0x101673ebe</span>, *b = <span class="number">0x101673ec6</span>
<span class="keyword">in</span> <span class="keyword">function</span> a<span class="attribute">'s</span> address <span class="number">0x7fff61272520</span>, b<span class="attribute">'s</span> address <span class="number">0x7fff61272518</span>
a = wife, a<span class="attribute">'s</span> pointer = <span class="number">0x101673ec6</span>, &a = <span class="number">0x7fff61272520</span>
b = husband, b<span class="attribute">'s</span> pointer = <span class="number">0x101673ebe</span>, &b = <span class="number">0x7fff61272518</span>
</pre></td></tr></table></figure>

<p>swapint工作的好好的，假设要是照葫芦画瓢写个swapchar你可以试试，肯定是没法工作的，因为在char*本身不会保存数据（保存数据的是内存堆,并不是一个字节的char），所以在*char解引用的时候得到的是堆地址的第一个字符（首地址）。上面的例子比较清楚，另外补充说明：一级指针解引后得到的是数据，而二级指针解引后得到的是数据的地址，也就是说我们在解引以及char的时候得到的数据，无法取得地址，从而没法进行char地址交换。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>void badswapchar(char <span class="variable">*a</span>, char <span class="variable">*b</span>)
{
  char temp = <span class="variable">*a</span>;
  <span class="variable">*a</span> = <span class="variable">*b</span>;
  <span class="variable">*b</span> = temp;
}
</pre></td></tr></table></figure>

<p>上面这个是不能工作的，当然，我们还可以把函数参数换成void<em>就可以工作了，void</em>可以转换成任意地址，这个强大的真让人赞叹，什么都能转换，有时候得需要一定的想象力才能把程序写的漂亮：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">void</span> badswapchar(<span class="keyword">void</span> *a, <span class="keyword">void</span> *b)
{
  <span class="keyword">char</span> *x = *((<span class="keyword">char</span>**)a); <span class="comment">// 先转换成一个二级指针，从而能取到堆的地址</span>

  *(<span class="keyword">char</span>**)a = *(<span class="keyword">char</span>**)b;
  *(<span class="keyword">char</span>**)b = x;
}
</pre></td></tr></table></figure>

<p>下面的这个例子是关于swap通用函数的使用，在C++中通常大多数会采用模板的方式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;string.h&gt;</span>

<span class="keyword">void</span> swap(<span class="keyword">void</span> *ap, <span class="keyword">void</span> *bp, <span class="keyword">int</span> size)
{
  <span class="keyword">char</span> buffer[size];

  <span class="built_in">memcpy</span>(buffer, ap, size);
  <span class="built_in">memcpy</span>(ap, bp, size);
  <span class="built_in">memcpy</span>(bp, buffer, size);
}

<span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)
{
  <span class="keyword">int</span> x = <span class="number">44</span>;
  <span class="keyword">short</span>  y = <span class="number">5</span>;
  <span class="built_in">printf</span>(<span class="string">"original x's memory layout:\n"</span>);
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(<span class="keyword">int</span>); i++)
    <span class="built_in">printf</span>(<span class="string">"%d "</span>, *((<span class="keyword">char</span>*)((<span class="keyword">char</span>*)&amp;x + i)));
  <span class="built_in">printf</span>(<span class="string">"\n"</span>);

  <span class="built_in">printf</span>(<span class="string">"original y's memory layout:\n"</span>);
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(<span class="keyword">short</span>); i++)
    <span class="built_in">printf</span>(<span class="string">"%d "</span>, *((<span class="keyword">char</span>*)((<span class="keyword">char</span>*)&amp;y + i)));
  <span class="built_in">printf</span>(<span class="string">"\n"</span>);

  swap(&amp;x, &amp;y, <span class="number">2</span>);

  <span class="built_in">printf</span>(<span class="string">"exchanged x's memory layout:\n"</span>);
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(<span class="keyword">int</span>); i++)
    <span class="built_in">printf</span>(<span class="string">"%d "</span>, *((<span class="keyword">char</span>*)((<span class="keyword">char</span>*)&amp;x + i)));
  <span class="built_in">printf</span>(<span class="string">"\n"</span>);

  <span class="built_in">printf</span>(<span class="string">"exchanged y's memory layout:\n"</span>);
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(<span class="keyword">short</span>); i++)
    <span class="built_in">printf</span>(<span class="string">"%d "</span>, *((<span class="keyword">char</span>*)((<span class="keyword">char</span>*)&amp;y + i)));
  <span class="built_in">printf</span>(<span class="string">"\n"</span>);

  <span class="built_in">printf</span>(<span class="string">"x = %d, y = %d\n"</span>, x, y);
  <span class="keyword">return</span> <span class="number">0</span>;
}
</pre></td></tr></table></figure>


<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>$ ./swap
original x's memory <span class="keyword">layout</span>:
<span class="number">44</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>
original y's memory <span class="keyword">layout</span>:
<span class="number">5</span> <span class="number">0</span>
exchanged x's memory <span class="keyword">layout</span>:
<span class="number">5</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>
exchanged y's memory <span class="keyword">layout</span>:
<span class="number">44</span> <span class="number">0</span>
x = <span class="number">5</span>, y = <span class="number">44</span>
</pre></td></tr></table></figure>

<p>这个例子如果在Big Endian机器上跑的话，会出现问题，大多数机器都会是Little Endian，像PowerPC,Motorola的CPU会是Big序.<br>网络传输大多目前都采用Big Endian，Java的网络采用的是Big Endian。</p>
<p>那我们来看下内存布局，将一个int跟short进行交换，int本身是4个字节，short两个字节，两个变量的空间不同必然会导致数据出现问题，但由于是little endian序，反而没问题。</p>
<p>补充一个检验机器是什么字节序的代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;stdio.h&gt;</span>

<span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)
{
  <span class="keyword">char</span> endian[<span class="number">2</span>] = {<span class="number">0</span>, <span class="number">1</span>};
  <span class="keyword">short</span> test = *(<span class="keyword">short</span>*)endian;
  <span class="keyword">if</span> (test == <span class="number">1</span>)
    <span class="built_in">printf</span>(<span class="string">"big endian\n"</span>);
  <span class="keyword">else</span>
    <span class="built_in">printf</span>(<span class="string">"little endian\n"</span>);
  <span class="keyword">return</span> <span class="number">0</span>;
}
</pre></td></tr></table></figure>



<p>下面是一个通用的search数组，找到index的例子，从中你可以感受到内存的操作和比较，注释掉的部分可以打开来代替memcmp函数的功能。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;string.h&gt;</span>
<span class="keyword">int</span> isearch(<span class="keyword">void</span> *key, <span class="keyword">void</span> *base, <span class="keyword">int</span> n, <span class="keyword">int</span> element_size)
{
  <span class="keyword">int</span> index = -<span class="number">1</span>;
  <span class="keyword">int</span> j = <span class="number">0</span>;

  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {
    <span class="keyword">void</span> *val = (<span class="keyword">char</span>*)base + i * element_size;
    <span class="keyword">if</span> (<span class="built_in">memcmp</span>(val, key, element_size) == <span class="number">0</span>)
      <span class="keyword">return</span> i;
    <span class="comment">/*
    for (j = 0; j &lt; element_size; j++) {
      if ( *((char*)((char*)key + j)) != *((char*)((char*)val + j)) )
        break;
    }
    if (j == element_size) {
      index = i;
      break;
    }
    */</span>
  }
  <span class="keyword">return</span> index;
}

<span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)
{
  <span class="keyword">int</span> arr[<span class="number">9</span>] = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>};
  <span class="keyword">int</span> k = <span class="number">4</span>;
  <span class="keyword">int</span> index = isearch(&amp;k, arr, <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]), <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]));
  <span class="built_in">printf</span>(<span class="string">"array is "</span>);
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]); i++)
    <span class="built_in">printf</span>(<span class="string">"%d "</span>, arr[i]);
  <span class="built_in">printf</span>(<span class="string">"\n"</span>);
  <span class="built_in">printf</span>(<span class="string">"find %d, index = %d\n"</span>, k, index);
  <span class="keyword">return</span> <span class="number">0</span>;
}
</pre></td></tr></table></figure>


<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>$./isearch
<span class="keyword">array</span> <span class="keyword">is</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>
find <span class="number">4</span>, <span class="keyword">index</span> = <span class="number">3</span>
</pre></td></tr></table></figure>

<p>好的，我们继续再来看看struct的内存布局的一个例子:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;stdio.h&gt;</span>

<span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)
{
  <span class="keyword">struct</span> fracnum {
    <span class="keyword">int</span> num;
    <span class="keyword">int</span> denum;
  };

  <span class="keyword">struct</span> fracnum pi;
  pi.num = <span class="number">22</span>;
  pi.denum = <span class="number">7</span>;

  <span class="built_in">printf</span>(<span class="string">"fracnum's size = %ld\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> fracnum));
  <span class="built_in">printf</span>(<span class="string">"&amp;pi = %p\n"</span>, &amp;pi);
  <span class="built_in">printf</span>(<span class="string">"&amp;(pi.denum) = %p\n"</span>, &amp;(pi.denum));
  <span class="built_in">printf</span>(<span class="string">"&amp;(pi.num) = %p\n"</span>, &amp;(pi.num));
  <span class="built_in">printf</span>(<span class="string">"((struct fracnum*)&amp;(pi.denum))-&gt;num = %d\n"</span>,
         ((<span class="keyword">struct</span> fracnum*)&amp;(pi.denum))-&gt;num);
  <span class="built_in">printf</span>(<span class="string">"((struct fracnum*)&amp;(pi.denum))-&gt;denum = %d\n"</span>,
         ((<span class="keyword">struct</span> fracnum*)&amp;(pi.denum))-&gt;denum);
  <span class="built_in">printf</span>(<span class="string">"&amp;(((struct fracnum*)&amp;(pi.denum))-&gt;denum) = %p\n"</span>,
         &amp;(((<span class="keyword">struct</span> fracnum*)&amp;(pi.denum))-&gt;denum));

  ((<span class="keyword">struct</span> fracnum*)&amp;(pi.denum))-&gt;num = <span class="number">12</span>; <span class="comment">// notice the address.</span>
  ((<span class="keyword">struct</span> fracnum*)&amp;(pi.denum))-&gt;denum = <span class="number">33</span>; <span class="comment">// over the boundary.</span>
  <span class="built_in">printf</span>(<span class="string">"num = %d denum = %d\n"</span>, pi.num, pi.denum); <span class="comment">// 22, 12</span>
  <span class="built_in">printf</span>(<span class="string">"unknown data = %d\n"</span>, *((<span class="keyword">int</span>*)((<span class="keyword">char</span>*)&amp;pi + <span class="number">8</span>))); <span class="comment">// 33</span>
  <span class="keyword">return</span> <span class="number">0</span>;
}
</pre></td></tr></table></figure>


<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>$ ./fracnum
fracnum's size = <span class="number">8</span>
&<span class="constant">pi</span> = <span class="number">0x7fff69aea528</span>
&(<span class="constant">pi</span>.denum) = <span class="number">0x7fff69aea52c</span>
&(<span class="constant">pi</span>.num) = <span class="number">0x7fff69aea528</span>
((struct fracnum*)&(<span class="constant">pi</span>.denum))-&gt;num = <span class="number">7</span>
((struct fracnum*)&(<span class="constant">pi</span>.denum))-&gt;denum = <span class="number">1773053288</span>
&(((struct fracnum*)&(<span class="constant">pi</span>.denum))-&gt;denum) = <span class="number">0x7fff69aea530</span>
num = <span class="number">22</span> denum = <span class="number">12</span>
unknown data = <span class="number">33</span>
</pre></td></tr></table></figure>

<p>从上述的结果中我们可以看到,struct的第一个字段即是struct的地址，然后指针是依次叠加。</p>
<p>但内存应该这么来读，最底下的也就是struct/num的指针，然后上面的是denum的指针：</p>
<p><code>denum</code> &nbsp;0x7fff6372152c</p>
<p><code>num</code>  &nbsp;&nbsp;&nbsp;  0x7fff63721528</p>
<p>这样访问，取struct fracnum<em>的时候，每次都是以8个字节（fracnum的长度来取的），所以在用denum取得时候，将<em>*向上</em></em>访问到内存，越出边界了，下面我用unknown来代替未知的数据。</p>
<p><code>unknown</code> &nbsp; 0x7fff63721530 -&gt; 33</p>
<p><code>denum</code> &nbsp;0x7fff6372152c -&gt; 12</p>
<p><code>num</code>  &nbsp;&nbsp;&nbsp;  0x7fff63721528 -&gt; 22</p>
<p>好吧，我们再说一下内存字节对齐的问题（引自coolshell.cn）：</p>
<ol>
<li>struct X { int a; char b; int c; };</li>
<li>printf(“%d,”, sizeof(struct X));</li>
<li>struct Y { int a; char b; int c; char d};</li>
<li>printf(“%d\n”, sizeof(struct Y));</li>
</ol>
<p>这个代码会输出什么?</p>
<ul>
<li>a) 9，10</li>
<li>b)12, 12</li>
<li>c)12, 16</li>
</ul>
<p>答案是C，我想，你一定知道字节对齐，是向4的倍数对齐。</p>
<ul>
<li>但是，你知道为什么要字节对齐吗？还是因为性能。因为这些东西都在内存里，如果不对齐的话，我们的编译器就要向内存一个字节一个字节的取，这样一来，struct X，就需要取9次，太浪费性能了，而如果我一次取4个字节，那么我三次就搞定了。所以，这是为了性能的原因。</li>
<li>但是，为什么struct Y不向12 对齐，却要向16对齐，因为char d; 被加在了最后，当编译器计算一个结构体的尺寸时，是边计算，边对齐的。也就是说，编译器先看到了int，很好，4字节，然后是 char，一个字节，而后面的int又不能填上还剩的3个字节，不爽，把char b对齐成4，于是计算到d时，就是13 个字节，于是就是16啦。但是如果换一下d和c的声明位置，就是12了。</li>
</ul>
<p>另外，再提一下，上述程序的printf中的%d并不好，因为，在64位下，sizeof的size_t是unsigned long，而32位下是 unsigned int，所以，C99引入了一个专门给size_t用的%zu。这点需要注意。在64位平台下，C/C++ 的编译需要注意很多事。</p>
<p>再来看一个数组struct的例子:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;string.h&gt;</span>

<span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)
{
  <span class="keyword">struct</span> student {
    <span class="keyword">char</span> *name;
    <span class="keyword">char</span> suid[<span class="number">8</span>];
    <span class="keyword">int</span> numUnits;
  };

  <span class="keyword">struct</span> student peoplies[<span class="number">4</span>];
  peoplies[<span class="number">0</span>].numUnits = <span class="number">21</span>;
  peoplies[<span class="number">2</span>].name = strdup(<span class="string">"Adam"</span>);
  peoplies[<span class="number">3</span>].name = peoplies[<span class="number">0</span>].suid + <span class="number">6</span>;
  <span class="built_in">strcpy</span>(peoplies[<span class="number">1</span>].suid, <span class="string">"40415xx"</span>);
  <span class="built_in">strcpy</span>(peoplies[<span class="number">3</span>].name, <span class="string">"123456"</span>);
  peoplies[<span class="number">7</span>].suid[<span class="number">11</span>] = <span class="string">'A'</span>;
  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, peoplies[<span class="number">0</span>].numUnits);
  <span class="comment">// out put 909456435, actually is 6543(little endian order)</span>
  <span class="comment">// the memory of stucture's mapping order is</span>
  <span class="comment">// declaration's order is oppsite in real memory.</span>
  <span class="comment">/**
     |  numUnits  |   numUnits  |  numUnits |  numUnits |
     |    suid    |     suid    |    suid   |    suid   |
     |    name    |     name    |    name   |    name   |
   */</span>

  <span class="keyword">return</span> <span class="number">0</span>;
}
</pre></td></tr></table></figure>



<p>继续，我们再来讨论下内存中栈和堆的存储方式。<br>每种编译器实现内存管理的方式都不同,malloc/realloc/free的方式都不同，这里不讨论具体某种编译器的实现了，实在太复杂，简单说说吧：<br>堆的实现，就像是一条链上的进行分配。</p>
<p>为什么redis在计算内存的时候自己做了计数器呢？因为加上不同平台的指针大小。实际上free函数在调用的时候也只是关心你malloc/realloc内存的时候自己的指针，如果你malloc(100)想释放其中一段内存的大小，这样是不对的，因为本身内存管理算法也不允许这样做，只是关心的是在malloc/realloc后自身的指针。还有内存碎片的产生，以及一些启发式内存管理算法，到底是先找到最匹配的空间分配还是直接在链上先分配，以及如何进行内存压缩等等，都是堆内存管理器干的事情。</p>
<p>再来简单说说栈管理，先看计算机的数据处理方式，数据能被处理，计算机需要将内存的数据载入计算器，然后再通过ALU(算数逻辑处理单元)进行处理，在写入到相应的寄存器，然后在写回内存。当然他们这之间是通过硅晶线进行连接（不好意思，具体电路方面不熟悉，暂且这么说吧）。</p>
<p>栈数据分为代码段和数据段，代码段的指令存储是每条指令都是32位，4个字节，这个跟机器多少位没关系。关于指令的移动，当然有专有的寄存器来存储当前运行到哪条指令，举个for循环的例子，汇编代码中，跳转jmp还有组合使用一些判定指令，然后进行指令的跳转，也就是形成了for循环的结构，汇编指令的编写有时候是需要写完后面的指令，才能在写跳出循环（jmp到最后边的指令，因为你不知道后面指令的地址所以没法跳出去）的指令。</p>
<p>为什么是32位的指令，汇编语言包含了59种命令，如何表示这59种命令，或者说机器如何来识别这些命令，翻译成机器码就是每条指令的前面6位。<br>然后5位用来表示要赋值的寄存器的，再用5位表示获取寄存器的位置，剩下的10位有可能表示一个有符号的常数。<br>这些都是有可能出现的分配位置的方式，并不是绝对的，也可能只用前面5位表示要赋值的寄存器，后面的全是常数等等，这取决于你的具体指令。</p>
<p>Stack的调用，每个函数都有自己的栈空间，只能访问当前栈空间的数据，也就是每个函数的局部变量，参数变量等等，函数的开始先进行压栈操作，结束后在调回栈顶，逐级返回，为什么在C语言中的递归会出现栈溢出？因为没有优化，C语言编译器(GCC等等)并不会做尾递归优化，像lisp这样的函数语言大多数都可以进行为递归优化，不消耗栈空间。</p>
<p>另外，二级指针的使用，介绍一片文章（来自coolshell.cn）<br><a href="http://coolshell.cn/articles/8990.html" target="_blank">Linus：利用二级指针删除单向链表</a></p>
<p>先写到这里，有时间再继续整理相关内存的一些文章~</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="请将此处替换成文章在你的站点中的ID" data-title="请替换成文章的标题" data-url="请替换成文章的网址"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"stevencui"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
<!-- 多说公共JS代码 end -->

  

  <nav id="pagination">
  
  
    <a href="/archives/2013/page/2/" class="alignright next">Next</a>
  
  <div class="clearfix"></div>
</nav>
</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:www.100hack.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">Categories</h3>
  <ul class="entry">
  
    <li><a href="/categories/C语言/">C语言</a><small>1</small></li>
  
    <li><a href="/categories/Erlang/">Erlang</a><small>1</small></li>
  
    <li><a href="/categories/Golang/">Golang</a><small>1</small></li>
  
    <li><a href="/categories/Java/">Java</a><small>1</small></li>
  
    <li><a href="/categories/Lua/">Lua</a><small>1</small></li>
  
    <li><a href="/categories/Python/">Python</a><small>1</small></li>
  
    <li><a href="/categories/Terminal/">Terminal</a><small>1</small></li>
  
    <li><a href="/categories/生活/">生活</a><small>1</small></li>
  
    <li><a href="/categories/编辑器/">编辑器</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">Tags</h3>
  <ul class="entry">
  
    <li><a href="/tags/Blog/">Blog</a><small>1</small></li>
  
    <li><a href="/tags/DES,ECB/">DES,ECB</a><small>1</small></li>
  
    <li><a href="/tags/Erlang/">Erlang</a><small>1</small></li>
  
    <li><a href="/tags/Fabric/">Fabric</a><small>1</small></li>
  
    <li><a href="/tags/Golang/">Golang</a><small>1</small></li>
  
    <li><a href="/tags/Netty/">Netty</a><small>1</small></li>
  
    <li><a href="/tags/Sublime/">Sublime</a><small>1</small></li>
  
    <li><a href="/tags/WebGame/">WebGame</a><small>1</small></li>
  
    <li><a href="/tags/zsh/">zsh</a><small>1</small></li>
  
    <li><a href="/tags/指针/">指针</a><small>1</small></li>
  
    <li><a href="/tags/统计/">统计</a><small>1</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2014 Steven
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<script type="text/javascript">
var disqus_shortname = 'steven_cui';

(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>



<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>